---
apiVersion: v1
kind: ConfigMap
metadata:
  name: sendgrid-mcp-server
  namespace: ai-system
  labels:
    app.kubernetes.io/name: sendgrid-mcp
data:
  server.py: |
    """SendGrid v3 API MCP server for email delivery diagnostics."""
    import json
    import os
    from typing import Optional

    import httpx
    from mcp.server.fastmcp import FastMCP
    from mcp.server.transport_security import TransportSecuritySettings

    SENDGRID_API_KEY = os.environ["SENDGRID_API_KEY"]
    BASE_URL = "https://api.sendgrid.com"
    HEADERS = {
        "Authorization": f"Bearer {SENDGRID_API_KEY}",
        "Content-Type": "application/json",
    }

    mcp = FastMCP(
        "sendgrid-mcp",
        host="0.0.0.0",
        port=8000,
        transport_security=TransportSecuritySettings(
            enable_dns_rebinding_protection=False,
        ),
    )


    async def _get(path: str, params: Optional[dict] = None) -> dict:
        async with httpx.AsyncClient(base_url=BASE_URL, headers=HEADERS, timeout=30) as client:
            resp = await client.get(path, params=params)
            resp.raise_for_status()
            return resp.json()


    @mcp.tool()
    async def search_email_activity(
        query: str,
        limit: int = 25,
    ) -> str:
        """Search SendGrid email activity (last 30 days only).

        The query parameter uses SendGrid query syntax. Examples:
        - to_email="user@example.com"
        - to_email="user@example.com" AND status="not_delivered"
        - to_email="user@example.com" AND last_event_time BETWEEN TIMESTAMP "2026-01-01" AND TIMESTAMP "2026-01-31"
        - from_email="sales@haydenagencies.com.au"
        - status="delivered" or status="not_delivered" or status="processing"
        - subject LIKE "%keyword%"

        Note: Customer-facing transactional emails have generic subjects (no order numbers).
        Search by to_email to find emails for a specific customer/order.
        """
        params = {"query": query, "limit": min(limit, 1000)}
        try:
            data = await _get("/v3/messages", params=params)
            messages = data.get("messages", [])
            if not messages:
                return "No email activity found matching that query."
            results = []
            for msg in messages:
                results.append({
                    "from_email": msg.get("from_email"),
                    "to_email": msg.get("to_email"),
                    "subject": msg.get("subject"),
                    "status": msg.get("status"),
                    "last_event_time": msg.get("last_event_time"),
                    "msg_id": msg.get("msg_id"),
                    "opens_count": msg.get("opens_count"),
                    "clicks_count": msg.get("clicks_count"),
                })
            return json.dumps(results, indent=2)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 403:
                return "Error: Email Activity Feed requires the 'Email Activity Feed' add-on. Check SendGrid plan."
            return f"SendGrid API error: {e.response.status_code} - {e.response.text}"


    @mcp.tool()
    async def get_email_activity_detail(msg_id: str) -> str:
        """Get detailed events for a specific email message by its msg_id.

        Use search_email_activity first to find the msg_id, then use this
        to see the full event timeline (processed, delivered, bounced, etc.).
        """
        try:
            data = await _get(f"/v3/messages/{msg_id}")
            return json.dumps(data, indent=2)
        except httpx.HTTPStatusError as e:
            return f"SendGrid API error: {e.response.status_code} - {e.response.text}"


    @mcp.tool()
    async def get_bounces(
        email: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 100,
    ) -> str:
        """Get bounced emails from SendGrid suppression list.

        Args:
            email: Filter by specific email address.
            start_time: Start of time range as Unix timestamp.
            end_time: End of time range as Unix timestamp.
            limit: Max results (default 100, max 500).
        """
        params = {"limit": min(limit, 500)}
        if start_time:
            params["start_time"] = start_time
        if end_time:
            params["end_time"] = end_time
        if email:
            try:
                data = await _get(f"/v3/suppression/bounces/{email}")
                return json.dumps(data, indent=2) if data else f"No bounce record found for {email}."
            except httpx.HTTPStatusError as e:
                if e.response.status_code == 404:
                    return f"No bounce record found for {email}."
                return f"SendGrid API error: {e.response.status_code} - {e.response.text}"
        data = await _get("/v3/suppression/bounces", params=params)
        if not data:
            return "No bounces found."
        return json.dumps(data, indent=2)


    @mcp.tool()
    async def get_blocks(
        email: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 100,
    ) -> str:
        """Get blocked emails from SendGrid suppression list.

        Blocks occur when the recipient's email server rejects the message.

        Args:
            email: Filter by specific email address.
            start_time: Start of time range as Unix timestamp.
            end_time: End of time range as Unix timestamp.
            limit: Max results (default 100, max 500).
        """
        params = {"limit": min(limit, 500)}
        if start_time:
            params["start_time"] = start_time
        if end_time:
            params["end_time"] = end_time
        if email:
            try:
                data = await _get(f"/v3/suppression/blocks/{email}")
                return json.dumps(data, indent=2) if data else f"No block record found for {email}."
            except httpx.HTTPStatusError as e:
                if e.response.status_code == 404:
                    return f"No block record found for {email}."
                return f"SendGrid API error: {e.response.status_code} - {e.response.text}"
        data = await _get("/v3/suppression/blocks", params=params)
        if not data:
            return "No blocks found."
        return json.dumps(data, indent=2)


    @mcp.tool()
    async def get_spam_reports(
        email: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 100,
    ) -> str:
        """Get spam reports from SendGrid suppression list.

        These are emails that recipients marked as spam.

        Args:
            email: Filter by specific email address.
            start_time: Start of time range as Unix timestamp.
            end_time: End of time range as Unix timestamp.
            limit: Max results (default 100, max 500).
        """
        params = {"limit": min(limit, 500)}
        if start_time:
            params["start_time"] = start_time
        if end_time:
            params["end_time"] = end_time
        if email:
            try:
                data = await _get(f"/v3/suppression/spam_reports/{email}")
                return json.dumps(data, indent=2) if data else f"No spam report found for {email}."
            except httpx.HTTPStatusError as e:
                if e.response.status_code == 404:
                    return f"No spam report found for {email}."
                return f"SendGrid API error: {e.response.status_code} - {e.response.text}"
        data = await _get("/v3/suppression/spam_reports", params=params)
        if not data:
            return "No spam reports found."
        return json.dumps(data, indent=2)


    @mcp.tool()
    async def get_invalid_emails(
        email: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 100,
    ) -> str:
        """Get invalid email addresses from SendGrid suppression list.

        These are addresses that were found to be invalid (DNS failures,
        mailbox not found, etc.).

        Args:
            email: Filter by specific email address.
            start_time: Start of time range as Unix timestamp.
            end_time: End of time range as Unix timestamp.
            limit: Max results (default 100, max 500).
        """
        params = {"limit": min(limit, 500)}
        if start_time:
            params["start_time"] = start_time
        if end_time:
            params["end_time"] = end_time
        if email:
            try:
                data = await _get(f"/v3/suppression/invalid_emails/{email}")
                return json.dumps(data, indent=2) if data else f"No invalid email record found for {email}."
            except httpx.HTTPStatusError as e:
                if e.response.status_code == 404:
                    return f"No invalid email record found for {email}."
                return f"SendGrid API error: {e.response.status_code} - {e.response.text}"
        data = await _get("/v3/suppression/invalid_emails", params=params)
        if not data:
            return "No invalid emails found."
        return json.dumps(data, indent=2)


    @mcp.tool()
    async def get_global_stats(
        start_date: str,
        end_date: Optional[str] = None,
        aggregated_by: Optional[str] = None,
    ) -> str:
        """Get global email sending statistics from SendGrid.

        Args:
            start_date: Start date in YYYY-MM-DD format.
            end_date: End date in YYYY-MM-DD format (defaults to today).
            aggregated_by: Aggregation period: 'day', 'week', or 'month'.
        """
        params = {"start_date": start_date}
        if end_date:
            params["end_date"] = end_date
        if aggregated_by:
            params["aggregated_by"] = aggregated_by
        data = await _get("/v3/stats", params=params)
        if not data:
            return "No statistics found for the given date range."
        return json.dumps(data, indent=2)


    @mcp.tool()
    async def get_suppression_groups() -> str:
        """List all suppression (unsubscribe) groups configured in SendGrid."""
        data = await _get("/v3/asm/groups")
        if not data:
            return "No suppression groups found."
        return json.dumps(data, indent=2)


    @mcp.tool()
    async def check_email_suppression(email: str) -> str:
        """Check all suppression lists for a specific email address.

        This is a convenience tool that checks bounces, blocks, spam reports,
        and invalid emails in one call. Useful for quickly diagnosing why an
        email address isn't receiving mail.
        """
        results = {}
        for suppression_type, path in [
            ("bounces", f"/v3/suppression/bounces/{email}"),
            ("blocks", f"/v3/suppression/blocks/{email}"),
            ("spam_reports", f"/v3/suppression/spam_reports/{email}"),
            ("invalid_emails", f"/v3/suppression/invalid_emails/{email}"),
        ]:
            try:
                data = await _get(path)
                if data:
                    results[suppression_type] = data
            except httpx.HTTPStatusError:
                pass
        if not results:
            return f"No suppression records found for {email}. The address is clear to receive email."
        return json.dumps(results, indent=2)


    if __name__ == "__main__":
        mcp.run(transport="streamable-http")
